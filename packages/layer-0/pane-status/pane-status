#!/bin/bash
# Shared pane detection utilities for Claude session management
# Source this file to use functions, or run directly for status checks
#
# Usage as library:
#   source /path/to/pane-status
#   if has_input_text "session-name"; then echo "Input detected"; fi
#   if is_pane_active "session-name"; then echo "Pane focused"; fi
#
# Usage as command:
#   pane-status <target> [--json]
#   pane-status tools          # Human-readable status
#   pane-status tools --json   # JSON output for scripts

# Check if there's real user input text after the ❯ prompt
# Returns 0 (true) if input detected, 1 (false) if clear
# Uses color detection: dim text (\e[2m) = placeholder, normal = real input
has_input_text() {
    local target="$1"
    # Capture WITH escape sequences to detect colors
    local pane_content=$(tmux capture-pane -t "$target" -p -e 2>/dev/null || echo "")
    local last_prompt=$(echo "$pane_content" | grep '❯' | tail -1)

    # No prompt found - no input
    [ -z "$last_prompt" ] && return 1

    # Extract everything after ❯ (including escape codes)
    local after_prompt="${last_prompt#*❯}"

    # Strip escape codes and leading whitespace for content check
    local text_only=$(echo "$after_prompt" | sed 's/\x1b\[[0-9;]*m//g' | sed 's/^[[:space:]]*//')

    # No text content - no input
    [ -z "$text_only" ] && return 1

    # Check for dim escape codes (placeholder/suggestion indicator)
    # \e[2m or \e[0;2m means dim/grey text = NOT real input
    if echo "$after_prompt" | grep -qE $'\x1b\[([0-9;]*;)?2m'; then
        return 1  # Dim text = placeholder, not real input
    fi

    # Also exclude "Try " suggestions (belt and suspenders)
    if [[ "$text_only" == Try\ * ]]; then
        return 1
    fi

    # Has real input (normal colored text)
    return 0
}

# Check if pane is currently focused (user might be about to type)
# Returns 0 (true) if active, 1 (false) if not
is_pane_active() {
    local target="$1"
    local active=$(tmux display-message -t "$target" -p '#{pane_active}' 2>/dev/null || echo "0")
    [ "$active" = "1" ]
}

# Check if Claude TUI is running (shows ❯ prompt)
# Returns 0 (true) if running, 1 (false) if not
is_claude_running() {
    local target="$1"
    tmux has-session -t "$target" 2>/dev/null || return 1
    tmux capture-pane -t "$target" -p 2>/dev/null | grep -q '❯'
}

# Check if Claude is actively working (spinner visible, action in progress)
# Returns 0 (true) if working, 1 (false) if idle/not running
is_claude_working() {
    local target="$1"
    local content=$(tmux capture-pane -t "$target" -p -S -20 2>/dev/null)

    # Check for spinner characters (braille dots)
    echo "$content" | grep -qE '[⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏]' && return 0

    # Check for ✱ with ... (action in progress)
    echo "$content" | grep -q '✱.*\.\.\.' && return 0

    # Check for selection UI (asking question)
    echo "$content" | grep -q 'Enter to select' && return 0

    return 1
}

# Ensure Claude is started in a tmux session, auto-start if needed
# Sets CLAUDE_WAS_STARTED=1 if we started it, 0 if already running
# Args: target, mode (continue|new)
# Returns 0 (true) if Claude is running, 1 (false) if failed
ensure_claude_started() {
    local target="$1"
    local mode="${2:-continue}"
    CLAUDE_WAS_STARTED=0

    # Check session exists
    tmux has-session -t "$target" 2>/dev/null || return 1

    # Already running? Done.
    if is_claude_running "$target"; then
        return 0
    fi

    # Start Claude
    CLAUDE_WAS_STARTED=1
    if [ "$mode" = "new" ]; then
        tmux send-keys -t "$target" "claude" Enter
    else
        tmux send-keys -t "$target" "claude -c" Enter
    fi

    # Wait for Claude to start (max 15s)
    local attempts=0
    while [ $attempts -lt 30 ]; do
        sleep 0.5
        if is_claude_running "$target"; then
            sleep 1  # Extra settle time
            return 0
        fi
        attempts=$((attempts + 1))
    done

    return 1
}

# Check if pane is safe to send message to
# Returns 0 (true) if safe, 1 (false) if blocked
# Blocking conditions:
#   - Claude not running (plain terminal)
#   - Claude is working (spinner, action in progress)
#   - Real user input in prompt (not placeholders)
# Note: pane_active is NOT checked - send even to focused panes
is_pane_safe_to_send() {
    local target="$1"

    # Unsafe if Claude is not running
    is_claude_running "$target" || return 1

    # Unsafe if Claude is actively working
    is_claude_working "$target" && return 1

    # Unsafe if real input text would get glued to message
    has_input_text "$target" && return 1

    return 0
}

# Get pane content (last N lines)
get_pane_content() {
    local target="$1"
    local lines="${2:-50}"
    tmux capture-pane -t "$target" -p -S "-${lines}" 2>/dev/null || echo ""
}

# CLI mode - run directly for status check
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    TARGET="$1"
    FORMAT="${2:-human}"

    # Help flag
    if [ "$TARGET" = "--help" ] || [ "$TARGET" = "-h" ]; then
        echo "pane-status - Detect Claude session state in tmux"
        echo ""
        echo "USAGE:"
        echo "  pane-status <session> [--json]"
        echo ""
        echo "EXAMPLES:"
        echo "  pane-status my-project         # Human-readable status"
        echo "  pane-status my-project --json  # JSON output for scripts"
        echo ""
        echo "OUTPUT:"
        echo "  claude_running  - Claude Code process is active"
        echo "  claude_working  - Claude is generating (not idle)"
        echo "  has_input       - User has typed text at prompt"
        echo "  pane_active     - Pane has focus"
        echo "  safe_to_send    - Safe to inject commands"
        echo ""
        echo "LIBRARY MODE:"
        echo "  source pane-status"
        echo "  is_claude_working \"session\" && echo \"busy\""
        exit 0
    fi

    if [ -z "$TARGET" ]; then
        echo "Usage: pane-status <target> [--json]" >&2
        echo "Run 'pane-status --help' for more info" >&2
        exit 1
    fi

    # Check session exists
    if ! tmux has-session -t "$TARGET" 2>/dev/null; then
        if [ "$FORMAT" = "--json" ]; then
            echo '{"exists":false}'
        else
            echo "Session not found: $TARGET"
        fi
        exit 1
    fi

    # Gather status
    CLAUDE_RUNNING=$(is_claude_running "$TARGET" && echo "true" || echo "false")
    CLAUDE_WORKING=$(is_claude_working "$TARGET" && echo "true" || echo "false")
    HAS_INPUT=$(has_input_text "$TARGET" && echo "true" || echo "false")
    PANE_ACTIVE=$(is_pane_active "$TARGET" && echo "true" || echo "false")
    SAFE_TO_SEND=$(is_pane_safe_to_send "$TARGET" && echo "true" || echo "false")

    if [ "$FORMAT" = "--json" ]; then
        printf '{"exists":true,"claude_running":%s,"claude_working":%s,"has_input":%s,"pane_active":%s,"safe_to_send":%s}\n' \
            "$CLAUDE_RUNNING" "$CLAUDE_WORKING" "$HAS_INPUT" "$PANE_ACTIVE" "$SAFE_TO_SEND"
    else
        echo "Session: $TARGET"
        echo "  Claude running: $CLAUDE_RUNNING"
        echo "  Claude working: $CLAUDE_WORKING"
        echo "  Has input text: $HAS_INPUT"
        echo "  Pane active:    $PANE_ACTIVE"
        echo "  Safe to send:   $SAFE_TO_SEND"
    fi
fi
